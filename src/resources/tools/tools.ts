// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../core/resource';
import * as ComprehendAPI from './comprehend';
import { Comprehend, ComprehendMedicalParams, ComprehendMedicalResponse } from './comprehend';
import { APIPromise } from '../../core/api-promise';
import { RequestOptions } from '../../internal/request-options';
import { path } from '../../internal/utils/path';

export class Tools extends APIResource {
  comprehend: ComprehendAPI.Comprehend = new ComprehendAPI.Comprehend(this._client);

  /**
   * Detects if content is AI- or human-generated, with a confidence score. Content
   * must have at least 350 characters
   *
   * @example
   * ```ts
   * const response = await client.tools.aiDetect({
   *   input:
   *     'AI and ML continue to be at the forefront of technological advancements. In 2025, we can expect more sophisticated AI systems that can handle complex tasks with greater efficiency. AI will play a crucial role in various sectors, including healthcare, finance, and manufacturing. For instance, AI-powered diagnostic tools will become more accurate, helping doctors detect diseases at an early stage. In finance, AI algorithms will enhance fraud detection and risk management.',
   * });
   * ```
   */
  aiDetect(body: ToolAIDetectParams, options?: RequestOptions): APIPromise<ToolAIDetectResponse> {
    return this._client.post('/v1/tools/ai-detect', { body, ...options });
  }

  /**
   * Splits a long block of text (maximum 4000 words) into smaller chunks while
   * preserving the semantic meaning of the text and context between the chunks.
   *
   * @example
   * ```ts
   * const response = await client.tools.contextAwareSplitting({
   *   strategy: 'llm_split',
   *   text: 'text',
   * });
   * ```
   */
  contextAwareSplitting(
    body: ToolContextAwareSplittingParams,
    options?: RequestOptions,
  ): APIPromise<ToolContextAwareSplittingResponse> {
    return this._client.post('/v1/tools/context-aware-splitting', { body, ...options });
  }

  /**
   * Parse PDF to other formats.
   *
   * @example
   * ```ts
   * const response = await client.tools.parsePdf('file_id', {
   *   format: 'text',
   * });
   * ```
   */
  parsePdf(
    fileID: string,
    body: ToolParsePdfParams,
    options?: RequestOptions,
  ): APIPromise<ToolParsePdfResponse> {
    return this._client.post(path`/v1/tools/pdf-parser/${fileID}`, { body, ...options });
  }
}

export interface ToolAIDetectResponse {
  label: 'fake' | 'real';

  score: number;
}

export interface ToolContextAwareSplittingResponse {
  /**
   * An array of text chunks generated by splitting the input text based on the
   * specified strategy.
   */
  chunks: Array<string>;
}

export interface ToolParsePdfResponse {
  /**
   * The extracted content from the PDF file, converted to the specified format.
   */
  content: string;
}

export interface ToolAIDetectParams {
  /**
   * The content to determine if it is AI- or human-generated. Content must have at
   * least 350 characters.
   */
  input: string;
}

export interface ToolContextAwareSplittingParams {
  /**
   * The strategy to use for splitting the text into chunks. `llm_split` uses the
   * language model to split the text, `fast_split` uses a fast heuristic-based
   * approach, and `hybrid_split` combines both strategies.
   */
  strategy: 'llm_split' | 'fast_split' | 'hybrid_split';

  /**
   * The text to split into chunks.
   */
  text: string;
}

export interface ToolParsePdfParams {
  /**
   * The format into which the PDF content should be converted.
   */
  format: 'text' | 'markdown';
}

Tools.Comprehend = Comprehend;

export declare namespace Tools {
  export {
    type ToolAIDetectResponse as ToolAIDetectResponse,
    type ToolContextAwareSplittingResponse as ToolContextAwareSplittingResponse,
    type ToolParsePdfResponse as ToolParsePdfResponse,
    type ToolAIDetectParams as ToolAIDetectParams,
    type ToolContextAwareSplittingParams as ToolContextAwareSplittingParams,
    type ToolParsePdfParams as ToolParsePdfParams,
  };

  export {
    Comprehend as Comprehend,
    type ComprehendMedicalResponse as ComprehendMedicalResponse,
    type ComprehendMedicalParams as ComprehendMedicalParams,
  };
}
