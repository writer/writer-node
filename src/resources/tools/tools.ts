// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../core/resource';
import * as ComprehendAPI from './comprehend';
import { Comprehend, ComprehendMedicalParams, ComprehendMedicalResponse } from './comprehend';
import { APIPromise } from '../../core/api-promise';
import { RequestOptions } from '../../internal/request-options';
import { path } from '../../internal/utils/path';

export class Tools extends APIResource {
  comprehend: ComprehendAPI.Comprehend = new ComprehendAPI.Comprehend(this._client);

  /**
   * Detects if content is AI- or human-generated, with a confidence score. Content
   * must have at least 350 characters
   *
   * @example
   * ```ts
   * const response = await client.tools.aiDetect({
   *   input:
   *     'AI and ML continue to be at the forefront of technological advancements. In 2025, we can expect more sophisticated AI systems that can handle complex tasks with greater efficiency. AI will play a crucial role in various sectors, including healthcare, finance, and manufacturing. For instance, AI-powered diagnostic tools will become more accurate, helping doctors detect diseases at an early stage. In finance, AI algorithms will enhance fraud detection and risk management.',
   * });
   * ```
   */
  aiDetect(body: ToolAIDetectParams, options?: RequestOptions): APIPromise<ToolAIDetectResponse> {
    return this._client.post('/v1/tools/ai-detect', { body, ...options });
  }

  /**
   * Splits a long block of text (maximum 4000 words) into smaller chunks while
   * preserving the semantic meaning of the text and context between the chunks.
   *
   * @example
   * ```ts
   * const response = await client.tools.contextAwareSplitting({
   *   strategy: 'llm_split',
   *   text: 'text',
   * });
   * ```
   */
  contextAwareSplitting(
    body: ToolContextAwareSplittingParams,
    options?: RequestOptions,
  ): APIPromise<ToolContextAwareSplittingResponse> {
    return this._client.post('/v1/tools/context-aware-splitting', { body, ...options });
  }

  /**
   * Parse PDF to other formats.
   *
   * @example
   * ```ts
   * const response = await client.tools.parsePdf('file_id', {
   *   format: 'text',
   * });
   * ```
   */
  parsePdf(
    fileID: string,
    body: ToolParsePdfParams,
    options?: RequestOptions,
  ): APIPromise<ToolParsePdfResponse> {
    return this._client.post(path`/v1/tools/pdf-parser/${fileID}`, { body, ...options });
  }

  /**
   * Search the web for information about a given query and return relevant results
   * with source URLs.
   *
   * @example
   * ```ts
   * const response = await client.tools.webSearch({
   *   include_domains: ['dev.writer.com'],
   *   query: 'How do I get an API key for the Writer API?',
   * });
   * ```
   */
  webSearch(body: ToolWebSearchParams, options?: RequestOptions): APIPromise<ToolWebSearchResponse> {
    return this._client.post('/v1/tools/web-search', { body, ...options });
  }
}

export interface ToolAIDetectResponse {
  label: 'fake' | 'real';

  score: number;
}

export interface ToolContextAwareSplittingResponse {
  /**
   * An array of text chunks generated by splitting the input text based on the
   * specified strategy.
   */
  chunks: Array<string>;
}

export interface ToolParsePdfResponse {
  /**
   * The extracted content from the PDF file, converted to the specified format.
   */
  content: string;
}

export interface ToolWebSearchResponse {
  /**
   * The search query that was submitted.
   */
  query: string;

  /**
   * The search results found.
   */
  sources: Array<ToolWebSearchResponse.Source>;

  /**
   * Generated answer based on the search results. Not included if `include_answer`
   * is `false`.
   */
  answer?: string;
}

export namespace ToolWebSearchResponse {
  export interface Source {
    /**
     * Raw content from the source URL. Not included if `include_raw_content` is
     * `false`.
     */
    raw_content?: string;

    /**
     * URL of the search result.
     */
    url?: string;
  }
}

export interface ToolAIDetectParams {
  /**
   * The content to determine if it is AI- or human-generated. Content must have at
   * least 350 characters.
   */
  input: string;
}

export interface ToolContextAwareSplittingParams {
  /**
   * The strategy to use for splitting the text into chunks. `llm_split` uses the
   * language model to split the text, `fast_split` uses a fast heuristic-based
   * approach, and `hybrid_split` combines both strategies.
   */
  strategy: 'llm_split' | 'fast_split' | 'hybrid_split';

  /**
   * The text to split into chunks.
   */
  text: string;
}

export interface ToolParsePdfParams {
  /**
   * The format into which the PDF content should be converted.
   */
  format: 'text' | 'markdown';
}

export interface ToolWebSearchParams {
  /**
   * Only applies when `search_depth` is `advanced`. Specifies how many text segments
   * to extract from each source. Limited to 3 chunks maximum.
   */
  chunks_per_source?: number;

  /**
   * Localizes search results to a specific country. Only applies to general topic
   * searches.
   */
  country?:
    | 'afghanistan'
    | 'albania'
    | 'algeria'
    | 'andorra'
    | 'angola'
    | 'argentina'
    | 'armenia'
    | 'australia'
    | 'austria'
    | 'azerbaijan'
    | 'bahamas'
    | 'bahrain'
    | 'bangladesh'
    | 'barbados'
    | 'belarus'
    | 'belgium'
    | 'belize'
    | 'benin'
    | 'bhutan'
    | 'bolivia'
    | 'bosnia and herzegovina'
    | 'botswana'
    | 'brazil'
    | 'brunei'
    | 'bulgaria'
    | 'burkina faso'
    | 'burundi'
    | 'cambodia'
    | 'cameroon'
    | 'canada'
    | 'cape verde'
    | 'central african republic'
    | 'chad'
    | 'chile'
    | 'china'
    | 'colombia'
    | 'comoros'
    | 'congo'
    | 'costa rica'
    | 'croatia'
    | 'cuba'
    | 'cyprus'
    | 'czech republic'
    | 'denmark'
    | 'djibouti'
    | 'dominican republic'
    | 'ecuador'
    | 'egypt'
    | 'el salvador'
    | 'equatorial guinea'
    | 'eritrea'
    | 'estonia'
    | 'ethiopia'
    | 'fiji'
    | 'finland'
    | 'france'
    | 'gabon'
    | 'gambia'
    | 'georgia'
    | 'germany'
    | 'ghana'
    | 'greece'
    | 'guatemala'
    | 'guinea'
    | 'haiti'
    | 'honduras'
    | 'hungary'
    | 'iceland'
    | 'india'
    | 'indonesia'
    | 'iran'
    | 'iraq'
    | 'ireland'
    | 'israel'
    | 'italy'
    | 'jamaica'
    | 'japan'
    | 'jordan'
    | 'kazakhstan'
    | 'kenya'
    | 'kuwait'
    | 'kyrgyzstan'
    | 'latvia'
    | 'lebanon'
    | 'lesotho'
    | 'liberia'
    | 'libya'
    | 'liechtenstein'
    | 'lithuania'
    | 'luxembourg'
    | 'madagascar'
    | 'malawi'
    | 'malaysia'
    | 'maldives'
    | 'mali'
    | 'malta'
    | 'mauritania'
    | 'mauritius'
    | 'mexico'
    | 'moldova'
    | 'monaco'
    | 'mongolia'
    | 'montenegro'
    | 'morocco'
    | 'mozambique'
    | 'myanmar'
    | 'namibia'
    | 'nepal'
    | 'netherlands'
    | 'new zealand'
    | 'nicaragua'
    | 'niger'
    | 'nigeria'
    | 'north korea'
    | 'north macedonia'
    | 'norway'
    | 'oman'
    | 'pakistan'
    | 'panama'
    | 'papua new guinea'
    | 'paraguay'
    | 'peru'
    | 'philippines'
    | 'poland'
    | 'portugal'
    | 'qatar'
    | 'romania'
    | 'russia'
    | 'rwanda'
    | 'saudi arabia'
    | 'senegal'
    | 'serbia'
    | 'singapore'
    | 'slovakia'
    | 'slovenia'
    | 'somalia'
    | 'south africa'
    | 'south korea'
    | 'south sudan'
    | 'spain'
    | 'sri lanka'
    | 'sudan'
    | 'sweden'
    | 'switzerland'
    | 'syria'
    | 'taiwan'
    | 'tajikistan'
    | 'tanzania'
    | 'thailand'
    | 'togo'
    | 'trinidad and tobago'
    | 'tunisia'
    | 'turkey'
    | 'turkmenistan'
    | 'uganda'
    | 'ukraine'
    | 'united arab emirates'
    | 'united kingdom'
    | 'united states'
    | 'uruguay'
    | 'uzbekistan'
    | 'venezuela'
    | 'vietnam'
    | 'yemen'
    | 'zambia'
    | 'zimbabwe';

  /**
   * For news topic searches, specifies how many days of news coverage to include.
   */
  days?: number;

  /**
   * Domains to exclude from the search. If unset, the search includes all domains.
   */
  exclude_domains?: Array<string>;

  /**
   * Whether to include a generated answer to the query in the response. If `false`,
   * only search results are returned.
   */
  include_answer?: boolean;

  /**
   * Domains to include in the search. If unset, the search includes all domains.
   */
  include_domains?: Array<string>;

  /**
   * Controls how raw content is included in search results:
   *
   * - `text`: Returns plain text without formatting markup
   * - `markdown`: Returns structured content with markdown formatting (headers,
   *   links, bold text)
   * - `true`: Same as `markdown`
   * - `false`: Raw content is not included (default if unset)
   */
  include_raw_content?: 'text' | 'markdown' | boolean;

  /**
   * Limits the number of search results returned. Cannot exceed 20 sources.
   */
  max_results?: number;

  /**
   * The search query.
   */
  query?: string;

  /**
   * Controls search comprehensiveness:
   *
   * - `basic`: Returns fewer but highly relevant results
   * - `advanced`: Performs a deeper search with more results
   */
  search_depth?: 'basic' | 'advanced';

  /**
   * Enables streaming of search results as they become available.
   */
  stream?: boolean;

  /**
   * Filters results to content published within the specified time range back from
   * the current date. For example, `week` or `w` returns results from the past 7
   * days.
   */
  time_range?: 'day' | 'week' | 'month' | 'year' | 'd' | 'w' | 'm' | 'y';

  /**
   * The search topic category. Use `news` for current events and news articles, or
   * `general` for broader web search.
   */
  topic?: 'general' | 'news';
}

Tools.Comprehend = Comprehend;

export declare namespace Tools {
  export {
    type ToolAIDetectResponse as ToolAIDetectResponse,
    type ToolContextAwareSplittingResponse as ToolContextAwareSplittingResponse,
    type ToolParsePdfResponse as ToolParsePdfResponse,
    type ToolWebSearchResponse as ToolWebSearchResponse,
    type ToolAIDetectParams as ToolAIDetectParams,
    type ToolContextAwareSplittingParams as ToolContextAwareSplittingParams,
    type ToolParsePdfParams as ToolParsePdfParams,
    type ToolWebSearchParams as ToolWebSearchParams,
  };

  export {
    Comprehend as Comprehend,
    type ComprehendMedicalResponse as ComprehendMedicalResponse,
    type ComprehendMedicalParams as ComprehendMedicalParams,
  };
}
